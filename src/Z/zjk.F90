PROGRAM ZJK
  USE BINIO
  USE ZSTEP
  USE OMP_LIB
  IMPLICIT NONE

  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: N, N_2, ID_MAG, ID_CMP, ID_TRU, INFO, NN, NM, NT, SZ(3), FD(3)
  TYPE(ZPROC) :: R

  COMPLEX(KIND=DWP), ALLOCATABLE, TARGET :: ZARR(:,:)
  COMPLEX(KIND=DWP), POINTER, CONTIGUOUS :: A(:,:), U(:,:), Z(:,:)
  REAL(KIND=DWP), ALLOCATABLE, TARGET :: DARR(:)
  REAL(KIND=DWP), POINTER, CONTIGUOUS :: S(:)
  INTEGER, ALLOCATABLE, TARGET :: IARR(:)
  INTEGER, POINTER, CONTIGUOUS :: J(:), P(:), Q(:), STEP(:)
  TYPE(AW), ALLOCATABLE, TARGET :: DZ(:)

  ! IF (.NOT. VERIFY_MIN_MAX(.FALSE.)) ERROR STOP 'MIN and/or MAX do NOT handle NaNs properly!'
  CALL SetCtrlC

  CALL READCL(FN, N, N_2, ID_MAG, ID_CMP, ID_TRU, INFO)
  IF (INFO .NE. 0) ERROR STOP 'zjk.exe FN N N_2 [ID_MAG [ID_CMP [ID_TRU]]]'
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,A)')   '    FN=', TRIM(FN)
  FLUSH(ERROR_UNIT)
  WRITE (ERROR_UNIT,'(A,I11)') '     N=', N
  FLUSH(ERROR_UNIT)
#endif
  IF (N .LE. 1) ERROR STOP 'N < 2'

  INFO = JSTEP_LEN(N, N_2)
  N_2 = INFO
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,I11)') '   N_2=', N_2
  FLUSH(ERROR_UNIT)
#endif
  IF (INFO .LE. 0) ERROR STOP 'JSTEP_LEN'

  ! number of threads
  NT = MIN(MAX(1, INT(OMP_GET_MAX_THREADS())), N_2)
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,I11)') '    NT=', NT
  FLUSH(ERROR_UNIT)
#endif

  CALL ZPROC_INIT(NT, ID_MAG, ID_CMP, ID_TRU, R, INFO)
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,I11)') 'ID_MAG=', ID_MAG
  FLUSH(ERROR_UNIT)
  WRITE (ERROR_UNIT,'(A,I11)') 'ID_CMP=', ID_CMP
  FLUSH(ERROR_UNIT)
  WRITE (ERROR_UNIT,'(A,I11)') 'ID_TRU=', ID_TRU
  FLUSH(ERROR_UNIT)
#endif
  IF (INFO .NE. 0) ERROR STOP 'ZPROC_INIT'

  CALL ZOPEN_YJ_RO(FN, N, N, SZ, FD, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(A,I11)') 'INFO=', INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP 'ZOPEN_YJ_RO'
  END IF

  ALLOCATE(ZARR(N, 3 * N))
  A => ZARR(:,1:N)
  U => ZARR(:,N+1:2*N)
  Z => ZARR(:,2*N+1:3*N)

  ALLOCATE(DARR(N))
  S => DARR(1:N)

  ALLOCATE(IARR(N * N + N_2))
  NN = (N * (N - 1)) / 2
  J => IARR(1:N)
  P => IARR(N+1:NN+N)
  Q => IARR(NN+N+1:2*NN+N)
  STEP => IARR(2*NN+N+1:2*NN+N+N_2)

  INFO = MOD(NN, NT)
  IF (INFO .GT. 0) INFO = NT - INFO
  NM = 2 * (NN + INFO)
  ALLOCATE(DZ(NM))
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,I11)') '    NM=', NM
  FLUSH(ERROR_UNIT)
#endif

  CALL ZREAD_YJ(FD, A, J, N, N, SZ, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(A,I11)') 'INFO=', INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP 'ZREAD_YJ'
  END IF
  CALL BCLOSEN(FD, 3)

  FD = 0
  DO INFO = 1, N
     IF (J(INFO) .EQ. 1) THEN
        FD(1) = FD(1) + 1
     ELSE IF (J(INFO) .EQ. -1) THEN
        FD(2) = FD(2) + 1
     ELSE ! error
        ERROR STOP 'invalid entry in J'
     END IF
  END DO
  WRITE (OUTPUT_UNIT,'(2(A,I11),A)') 'J contains', FD(1), ' positive and', FD(2), ' negative signs.'
  FLUSH(OUTPUT_UNIT)

  CALL R%TRU(N, P, Q, NN, INFO)
  IF (INFO .NE. NN) THEN
     WRITE (ERROR_UNIT,'(A,I11)') 'INFO=', INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP 'R%TRU'
  END IF
#ifndef NDEBUG
  WRITE (ERROR_UNIT,'(A,I11)') '    NN=', NN
  FLUSH(ERROR_UNIT)
#endif

  FD(1) = GET_THREAD_NS()
  CALL ZSTEP_LOOP(NT, N, U, N, A, N, Z, N, J, S, NN, P, Q, R, NM, DZ, N_2, STEP, INFO)
  FD(1) = GET_THREAD_NS() - FD(1)
  IF (INFO .GE. 0) THEN
     WRITE (OUTPUT_UNIT,'(A,I10,A,F12.6,A)') 'Executed ', INFO, ' steps with transformations in ', (FD(1) * DNS2s), ' s'
     FLUSH(OUTPUT_UNIT)
  ELSE ! error
     WRITE (ERROR_UNIT,'(A,I10,A,F12.6,A)') 'ERROR ', INFO, ' after ', (FD(1) * DNS2s), ' s'
     FLUSH(ERROR_UNIT)
  END IF

  IF (ALLOCATED(DZ)) DEALLOCATE(DZ)
  STEP => NULL()
  Q => NULL()
  P => NULL()
  J => NULL()
  IF (ALLOCATED(IARR)) DEALLOCATE(IARR)

  CALL ZOPEN_UZS_RW(FN, N, N, SZ, FD, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(A,I11)') 'INFO=', INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP 'ZOPEN_UZS_RW'
  END IF

  CALL ZWRITE_UZS(FD, U, Z, S, N, N, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ERROR_UNIT,'(A,I11)') 'INFO=', INFO
     FLUSH(ERROR_UNIT)
     ERROR STOP 'ZWRITE_UZS'
  END IF

  CALL BCLOSEN(FD, 3)

  S => NULL()
  IF (ALLOCATED(DARR)) DEALLOCATE(DARR)
  Z => NULL()
  U => NULL()
  A => NULL()
  IF (ALLOCATED(ZARR)) DEALLOCATE(ZARR)

CONTAINS
#include "readcl.F90"
#include "bio.F90"
END PROGRAM ZJK
